#!/bin/bash
# SOURCE: https://github.com/iridakos/stup
# MIT License
#
# Copyright (c) 2020 Lazarus Lazaridis
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#############
# Variables #
#############

# TODO: remove unused
NOTES=()
TEXT_BOLD=$(tput bold)
TEXT_BLACK=$(tput setaf 0)
TEXT_RED=$(tput setaf 1)
TEXT_GREEN=$(tput setaf 2)
TEXT_YELLOW=$(tput setaf 3)
TEXT_LIME_YELLOW=$(tput setaf 190)
TEXT_POWDER_BLUE=$(tput setaf 153)
TEXT_BLUE=$(tput setaf 4)
TEXT_MAGENTA=$(tput setaf 5)
TEXT_CYAN=$(tput setaf 6)
TEXT_WHITE=$(tput setaf 7)
TEXT_BRIGHT=$(tput bold)
TEXT_NORMAL=$(tput sgr0)
TEXT_BLINK=$(tput blink)
TEXT_REVERSE=$(tput smso)
TEXT_UNDERLINE=$(tput smul)
TEXT_NORMAL=$(tput sgr0)

# Stup entry point
stup()
{
  resolve_configuration_file
  parse_options "$@"

  if [ -z "$COMMAND" ]; then
    COMMAND="show"
  fi

  if [ "$COMMAND" != "configure" ]; then
    ensure_configured
    load_configuration
  fi

  execute
}

######################
# Command executions #
######################

# Issues the execution of the proper command
execute()
{
  case "$COMMAND" in
    show)
      execute_show
      ;;
    add)
      execute_add
      ;;
    edit)
      execute_edit
      ;;
    configure)
      execute_configure
      ;;
    add_repository)
      execute_add_repository
      ;;
    list_repositories)
      execute_list_repositories
      ;;
    order_repositories)
      execute_order_repositories
      ;;
    set_repository_description)
      execute_set_repository_description
      ;;
    *)
      print_error "Can't execute command: '$COMMAND'"
      exit 1
      ;;
  esac
}

# Shows the notes added for a specific date
execute_show()
{
  if [[ $1 ]]; then
    AT="$1"
  fi

  resolve_date
  extract_date_components

  if [[ $REPOSITORY ]]; then
    target_file=$(resolve_target_file "$REPOSITORY")

    if [ -f "$target_file" ]; then
      echo -e "Displaying notes of repository $REPOSITORY added for $(success_color "$(display_date "$AT")")."

      local description_file="$REPOSITORIES_ROOT/$REPOSITORY/description.md"

      if [ -f "$description_file" ]; then
        description="$(emphasize "$(cat $description_file)")"
      else
        description="$(emphasize "# Notes in repository: $repository")"
      fi

      print_info "\n>> $description\n"
      sed -e 's/^/ /' "$target_file"

      echo ""
    else
      print_warning "No entries found for $(display_date $AT) in repository $REPOSITORY."
      read -e -p "Do you want to retrieve the last entries added in this repository with stup? Type y|Y|yes|Yes or anything else to exit: " search_last_entries

      case "$search_last_entries" in
        y|Y|yes|Yes)
          resolve_last_at
          execute_show "$AT"
          ;;
        *)
          exit 0
      esac
    fi
  else
    load_repositories

    # Check if there are any entries for the given date
    local entries_found=false
    for repository in "${REPOSITORIES[@]}"; do
      local target_file=$(resolve_target_file "$repository")

      if [ -f "$target_file" ]; then
        entries_found=true
        break
      fi
    done

    if [ $entries_found == true ]; then
      echo -e "Displaying notes added for $(display_date "$AT")."

      for repository in "${REPOSITORIES[@]}"; do
        local description_file="$REPOSITORIES_ROOT/$repository/description.md"
        local target_file=$(resolve_target_file "$repository")
        local empty_repo=false

        if [ -f "$description_file" ]; then
          description="$(emphasize "$(cat $description_file)")"
        else
          description="$(emphasize "# Notes in repository: $repository")"
        fi

        if [ -f "$target_file" ]; then
          IFS=$'\n' read -d '' -r -a contents < <(cat "$target_file" | tr -d '[:space:]')

          if [ ${#contents[@]} -eq 0 ]; then
            empty_repo=true
          fi
        else
          empty_repo=true
        fi

        if [ "$empty_repo" = "true" ]; then
          if [ "$INCLUDE_EMPTY" = true ]; then
            print_info "\n>> $description\n"
            print_warning "   None."
          fi
        else
          print_info "\n>> $description\n"
          sed -e 's/^/ /' "$target_file"
        fi
      done

      echo ""
    else
      print_warning "No entries found for $(display_date $AT) in any repository."
      read -e -p "Do you want to retrieve the last entries added with stup? Type y|Y|yes|Yes or anything else to exit: " search_last_entries

      case "$search_last_entries" in
        y|Y|yes|Yes)
          resolve_last_at
          execute_show "$AT"
          ;;
        *)
          exit 0
      esac
    fi
  fi
}

# Adds notes to a specific date
execute_add()
{
  resolve_required_repository
  resolve_date
  extract_date_components

  local number_of_notes=${#NOTES[@]}

  if [ $number_of_notes -eq 0 ]; then
    print_error "You haven't specified any notes to add."
    print_hint "Use the --note or -n flag."
    exit 1
  fi

  target_file="$(resolve_target_file $REPOSITORY)"

  if ! [ -f "$target_file" ]; then
    mkdir -p "${target_file%/*}" && touch "$target_file"
  fi

  for item in "${NOTES[@]}"; do
    echo "- $item" >> $target_file
  done

  echo -e "Successfully added $(emphasize "$number_of_notes") notes in repository $(emphasize "$REPOSITORY") for $(display_date $AT)"
}

# Opens the file keeping the notes of a specific date for edit in user's default editor
execute_edit()
{
  resolve_required_repository
  resolve_date
  extract_date_components

  local target_file="$(resolve_target_file "$REPOSITORY")"

  print_info "About to edit: $target_file"

  if ! [ -f "$target_file" ]; then
    print_warning "Notes for repository "$REPOSITORY" on $(display_date "$AT") does not exist."
    read -e -p ">>> Type yes|y to create and edit the file or anything else to abort: " response

    if ! [[ "$response" = 'y' || "$response" = 'yes' ]]; then
      echo 'Aborted.'
      exit 0
    fi
  fi

  local target_directory="$(dirname "$target_file")"
  mkdir -p "$target_directory"

  if [ -z "$STUP_EDITOR" ]; then
    STUP_EDITOR="vi"
  fi

  $STUP_EDITOR "$target_file"
}

# Adds a repository
execute_add_repository()
{
  if [ -z "$REPOSITORY_NAME" ]; then
    print_error "Missing required argument --repository-name"
    exit 1
  fi

  if [ -d "$REPOSITORIES_ROOT/$REPOSITORY_NAME" ]; then
    print_warning "Repository '$REPOSITORY_NAME' directory already exists. Ensuring its presence in the repositories configuration file as well."
  else
    mkdir -p "$REPOSITORIES_ROOT/$REPOSITORY_NAME"
    print_success "Successfully created repository '$REPOSITORY_NAME'"
  fi

  store_repository_configuration "$REPOSITORY_NAME"

  if ! [ -z "$REPOSITORY_DESCRIPTION" ]; then
    echo "$REPOSITORY_DESCRIPTION" > "$REPOSITORIES_ROOT/$REPOSITORY_NAME/description.md"
  fi
}

# Shows current repositories
execute_list_repositories()
{
  load_repositories

  printf '%s\n' "${REPOSITORIES[@]}"
}

# Opens the repositories configuration file for edit
execute_order_repositories()
{
  local conf="$(resolve_repositories_configuration_file)"

  if ! [ -f "$conf" ]; then
    print_error "problem"
    exit 1
  fi

  if [ -z "$STUP_EDITOR" ]; then
    STUP_EDITOR="vi"
  fi

  $STUP_EDITOR "$conf"
}

# Updates the description of a given repository
execute_set_repository_description()
{
  if [ -z "$REPOSITORY_DESCRIPTION" ]; then
    echo "Missing required argument --repository-description"
    exit 1
  fi

  if [ -z "$REPOSITORY" ]; then
    echo "No repository specified. Changing the default: $DEFAULT_REPOSITORY"
    REPOSITORY="$DEFAULT_REPOSITORY"
  fi

  echo -e "$REPOSITORY_DESCRIPTION" > "$REPOSITORIES_ROOT/$REPOSITORY/description.md"
}

# Configures stup via a wizard
execute_configure()
{
  if ! [ -f "$CONFIG_FILE" ]; then
    fist_time=true
    touch -a "$CONFIG_FILE"
    echo -e "repositories_root=$HOME/stup\ndefault_repository=main\n" >> $CONFIG_FILE
  fi

  load_configuration

  wizard "repositories_root"
  wizard "default_repository"
  wizard "stup_editor"

  store_configuration

  exit 0
}

##########################
# Command helper methods #
##########################

# Ensures stup is configured
ensure_configured()
{
  if ! [ -f "$CONFIG_FILE" ]; then
    print_error "Failed to find configuration file: $CONFIG_FILE"
    print_hint "Have you configured stup? If not, use: stup configure"
    exit 1
  fi

  load_configuration

  if [ -z "$REPOSITORIES_ROOT" ]; then
    print_error "Invalid stup configuration - missing repositories root"
    print_hint "Use \"stup --configure\" to re-configure stup"
    exit 1
  fi

  if [ -z "$DEFAULT_REPOSITORY" ]; then
    print_error "Invalid stup configuration - missing default repository"
    print_hint "Use \"stup --configure\" to re-configure stup"
    exit 1
  fi

  if ! [ -d "$REPOSITORIES_ROOT" ]; then
    print_error "Invalid stup configuration - repositories root directory does not exist"
    print_hint "Use \"stup --configure\" to re-configure stup"
    exit 1
  fi

  if ! [ -f "$(resolve_repositories_configuration_file)" ]; then
    print_error "Invalid stup configuration - missing repositories configuration file"
    print_hint "Use \"stup --configure\" to re-configure stup"
    exit 1
  fi
}

# Parses the user's options
parse_options()
{
  while [[ $# -gt 0 ]]; do
    case "$1" in
      today|tomorrow|yesterday)
        AT="$1"
        shift
        ;;
      --add|add)
        COMMAND="add"
        shift
        ;;
      --show|show)
        COMMAND="show"
        shift
        ;;
      --include-empty)
        INCLUDE_EMPTY=true
        shift
        ;;
      --edit|edit)
        COMMAND="edit"
        shift
        ;;
      @|-@|--at)
        AT="$2"
        shift 2
        ;;
      --add-repository|add-repository)
        COMMAND="add_repository"
        shift
        ;;
      --order-repositories|order-repositories)
        COMMAND="order_repositories"
        shift
        ;;
      --set-repository-description|set-repository-description)
        COMMAND="set_repository_description"
        shift
        ;;
      --list-repositories|list-repositories|repositories)
        COMMAND="list_repositories"
        shift
        ;;
      --repository-name)
        REPOSITORY_NAME="$2"
        shift 2
        ;;
      --repository-description)
        REPOSITORY_DESCRIPTION="$2"
        shift 2
        ;;
      -r|--repository)
        load_configuration
        load_repositories

        if [[ ! " ${REPOSITORIES[@]} " =~ " ${2} " ]]; then
          print_error "Repository "$2" does not exist."
          exit 1
        fi

        REPOSITORY="$2"
        shift 2
        ;;
      -n|--note)
        NOTES+=("$2")
        shift 2
        ;;
      --configure|configure)
        COMMAND="configure"
        shift
        ;;
      --) # end argument parsing
        shift
        break
        ;;
      -*|--*=) # unsupported flags
        echo "Error: Unsupported flag $1" >&2
        exit 1
        ;;
      *)
        echo "Error: Unsupported command \"$1\"" >&2
        exit 1
        ;;
    esac
  done
}

# Starts the configuration wizard
wizard()
{
  case "$1" in
    repositories_root)
      if [ -z "$REPOSITORIES_ROOT" ]; then
        REPOSITORIES_ROOT="$HOME/stup"
      fi

      if [[ "$2" ]]; then
        print_error "$2"
      else
        print_info "Please specify which directory will be the root of all the repositories stup will be using to store your notes."
        print_info "By default, the notes will be stored in $REPOSITORIES_ROOT."
      fi

      read -e -p ">>> Press enter to use the default location or fill in your desired destination: " new_repository_root
      new_repository_root=$(echo -e "${new_repository_root}" | tr -d '[:space:]')

      case "$new_repository_root" in
        "")
          print_success "Keeping default directory."
          mkdir -p "$REPOSITORIES_ROOT"
          touch -a "$(resolve_repositories_configuration_file)"
          ;;
        *)
          {
            new_repository_root="${new_repository_root/#\~/$HOME}"
            new_repository_root=$(readlink -f "$new_repository_root")

            mkdir -p "$new_repository_root"

            new_repository_root=$(builtin cd "$new_repository_root" 2>/dev/null && pwd)

            if [[ -d "$new_repository_root" ]]; then
              REPOSITORIES_ROOT="$new_repository_root"
              touch -a "$(resolve_repositories_configuration_file)"
            else
              wizard "repositories_root" "Failed to create the new repository root."
            fi
          } || {
            wizard "repositories_root" "Failed to create the new repository root, make sure it's a valid path."
          }
          ;;
      esac
      ;;
    default_repository)
      if [ -z "$DEFAULT_REPOSITORY" ]; then
        DEFAULT_REPOSITORY="main"
      fi

      if [[ "$2" ]]; then
        print_error "$2"
      else
        print_info "Please specify which repository will be your default one (if you have many)."
        print_info "The default repository is currently set to \"$DEFAULT_REPOSITORY\"."
      fi

      read -e -p ">>> Press enter to keep the default or fill in a new one (ex. review): " new_default_repository
      new_default_repository=$(echo -e "${new_default_repository}" | tr -d '[:space:]')

      case "$new_default_repository" in
        "")
          print_success "Default repository still set to \"$DEFAULT_REPOSITORY\"."
          store_repository_configuration "$DEFAULT_REPOSITORY"
          ;;
        *)
          {
            mkdir -p "$REPOSITORIES_ROOT/$new_default_repository"

            if [[ -d "$REPOSITORIES_ROOT/$new_default_repository" ]]; then
              DEFAULT_REPOSITORY="$new_default_repository"
              print_success "Default repository set to $DEFAULT_REPOSITORY"
              store_repository_configuration "$DEFAULT_REPOSITORY"
            else
              wizard "default_repository" "Failed to create the default repository's directory. Make sure the name is also a valid directory name."
            fi
          } || {
            wizard "default_repository" "Failed to create the directory for the new default repository. Make sure the name is also a valid directory name."
          }
          ;;
      esac
      ;;
    stup_editor)
      if [ -z "$STUP_EDITOR" ]; then
        STUP_EDITOR="vi"
      fi

      if [[ "$2" ]]; then
        print_error "$2"
      else
        print_info "Please specify which editor you want to use when manually editing your notes."
        print_info "The default editor is currently set to \"$STUP_EDITOR\"."
      fi

      read -e -p ">>> Press enter to keep the default or fill in a new one (ex. vim): " new_stup_editor
      new_stup_editor=$(echo -e "${new_stup_editor}" | tr -d '[:space:]')

      if ! [[ -z "$new_stup_editor" ]]; then
        STUP_EDITOR="$new_stup_editor"
        print_success "Stup editor set to: $STUP_EDITOR"

      else
        print_success "Keeping the default editor: $STUP_EDITOR."
      fi
  esac
}

# Loads the stup configuration
load_configuration()
{
  if [[ $CONFIGURATION_LOADED == true ]]; then
    return
  fi

  if [ -z CONFIG_FILE ]; then
    print_error "Configuration file not found."
    print_hint "Have you configured stup?"
    exit 1
  fi

  while IFS='=' read variable_name variable_value
  do
    if [[ $variable_value ]]
    then
      handle_configuration_variable "$variable_name" "$variable_value"
    fi
  done < $CONFIG_FILE

  CONFIGURATION_LOADED=true
}

# Loads the configuration variables
handle_configuration_variable()
{
  case "$1" in
    repositories_root)
      REPOSITORIES_ROOT="$2"
      ;;
    default_repository)
      DEFAULT_REPOSITORY="$2"
      ;;
    stup_editor)
      STUP_EDITOR="$2"
      ;;
  esac
}

# Resolves the location of the stup configuration file
resolve_configuration_file()
{
  CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/stup.conf"
}

# Stores configuration of stup
store_configuration()
{
  echo -e "repositories_root=$REPOSITORIES_ROOT
default_repository=$DEFAULT_REPOSITORY
stup_editor=$STUP_EDITOR
" > $CONFIG_FILE
}

store_repository_configuration()
{
  load_repositories

  local repository_to_store="$1"

  if ! $(array_contains REPOSITORIES "$repository_to_store") ; then
    echo "$repository_to_store" >> "$(resolve_repositories_configuration_file)"
  fi
}

# Properly sets the current repository to the default one unless already specified
resolve_required_repository()
{
  if [[ -z "$REPOSITORY" ]]; then
    REPOSITORY="$DEFAULT_REPOSITORY"
  fi
}

# Properly sets year, month and day based on the specified AT variable
# TODO: print error on invalid date format
extract_date_components()
{
  case "$AT" in
    today|yesterday|tomorrow)
      YEAR=$(date -d "$AT" +"%Y")
      MONTH=$(date -d "$AT" +"%m")
      DAY=$(date -d "$AT" +"%d")
      ;;
    *)
      IFS='-' read -ra parts <<< "$AT"
      YEAR="${parts[0]}"
      MONTH="${parts[1]}"
      DAY="${parts[2]}"
      ;;
  esac
}

# Loads the currently registered repositories
load_repositories()
{
  IFS=$'\n' read -d '' -r -a REPOSITORIES < "$(resolve_repositories_configuration_file)"
}

# Checks if array has an element
# https://stackoverflow.com/a/14367368/2292448
array_contains () {
  local array="$1[@]"
  local seeking=$2
  for element in "${!array}"; do
    [[ $element == "$seeking" ]] && return
  done

  false
}

# Sets the default date per action if not specified by the user
resolve_date()
{
  if [ ! -z "$AT" ]; then
    return
  fi

  case "$COMMAND" in
    show)
      AT="yesterday"
      ;;
    add|edit)
      AT="today"
      ;;
    *)
      echo "[WARN] don't know how to handle default date for command: $COMMAND"
      ;;
  esac
}

# Retrieves the last date a note was issued before a specified date
resolve_last_at()
{
  local year=$YEAR,month=$MONTH,day=$DAY,last_at=""
  local target_path=""
  local current_target_file=$(basename $(resolve_target_file))
  local winner=""
  local current_at="$AT"
  AT=""

  # TODO: optimize this search, it can get too big with the increase of entries
  ########################
  # search in month days #
  ########################
  if [[ $REPOSITORY ]]; then
    target_path="$REPOSITORY/$YEAR/$MONTH"
  else
    target_path="*/$YEAR/$MONTH"
  fi

  while IFS= read -r filename; do
    if [[ "$current_target_file" > "$filename" ]]; then
      AT="${filename%.*}"
      return
    fi
  done < <(find $REPOSITORIES_ROOT -path "$target_path/*.md" -printf "%f\n" | sort -r)

  #########################
  # search in year months #
  #########################
  if [[ $REPOSITORY ]]; then
    target_path="$REPOSITORY/$YEAR/*"
  else
    target_path="*/$YEAR/*"
  fi

  while IFS= read -r filename; do
    if [[ "$current_target_file" > "$filename" ]]; then
      AT="${filename%.*}"
      return
    fi
  done < <(find $REPOSITORIES_ROOT -path "$target_path/*.md" -printf "%f\n" | sort -r)

  ###################
  # search in years #
  ###################
  if [[ $REPOSITORY ]]; then
    target_path="$REPOSITORY/*/*"
  else
    target_path="*/*/*"
  fi

  while IFS= read -r filename; do
    if [[ "$current_target_file" > "$filename" ]]; then
      AT="${filename%.*}"
      return
    fi
  done < <(find $REPOSITORIES_ROOT -path "$target_path/*.md" -printf "%f\n" | sort -r)

  # Exit if no previous notes file found.
  if [ -z "$AT" ]; then
    print_warning "No entries found prior to $(display_date "$current_at")."
    exit 0
  fi
}

# Displays human date in green
# TODO: must find a better way for handling colored output
display_date()
{
  echo $(success_color "$(date --date "$1" +"%A %B %d, %Y")")
}

# Resolves the filename of the stup entry for a specific date at a specific repository
resolve_target_file()
{
  echo "$REPOSITORIES_ROOT/$1/$YEAR/$MONTH/$YEAR-$MONTH-$DAY.md"
}

# Resolves the filename of the repositories configuration
resolve_repositories_configuration_file()
{
  echo "$REPOSITORIES_ROOT/repositories.conf"
}

#####################
# UI Helper methods #
#####################

print_error()
{
  echo -e "${TEXT_RED}$1${TEXT_NORMAL}"
}

print_warning()
{
  echo -e "${TEXT_YELLOW}$1${TEXT_NORMAL}"
}

print_hint()
{
  echo -e "${TEXT_POWDER_BLUE}$1${TEXT_NORMAL}"
}

print_info()
{
  echo -e "${TEXT_BLUE}$1${TEXT_NORMAL}"
}

print_success()
{
  echo -e "${TEXT_GREEN}$1${TEXT_NORMAL}"
}

success_color()
{
  echo "${TEXT_GREEN}$1${TEXT_NORMAL}"
}

emphasize()
{
  echo "${TEXT_BOLD}$1${TEXT_NORMAL}"
}

# Let's go
stup "$@"; exit